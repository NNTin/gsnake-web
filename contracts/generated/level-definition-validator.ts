// @ts-nocheck
// This file is generated by scripts/contracts/generate-level-definition-validator.mjs.
// Do not edit this file manually.

"use strict";
export const validateLevelDefinition = validate20;
const schema31 = {
  $schema: "https://json-schema.org/draft/2020-12/schema",
  $id: "https://gsnake.dev/schemas/level-definition.schema.json",
  title: "LevelDefinition",
  description: "Canonical cross-runtime level contract for gSnake.",
  type: "object",
  additionalProperties: false,
  required: [
    "id",
    "name",
    "gridSize",
    "snake",
    "obstacles",
    "food",
    "exit",
    "snakeDirection",
    "totalFood",
  ],
  properties: {
    id: {
      type: "integer",
      minimum: 0,
      maximum: 4294967295,
      description: "Stable level identifier (u32-compatible).",
    },
    name: { type: "string", minLength: 1 },
    difficulty: { type: "string" },
    gridSize: {
      type: "object",
      additionalProperties: false,
      required: ["width", "height"],
      properties: {
        width: { type: "integer", minimum: 1, maximum: 2147483647 },
        height: { type: "integer", minimum: 1, maximum: 2147483647 },
      },
    },
    snake: { type: "array", minItems: 1, items: { $ref: "#/$defs/position" } },
    obstacles: { type: "array", items: { $ref: "#/$defs/position" } },
    food: { type: "array", items: { $ref: "#/$defs/position" } },
    exit: { $ref: "#/$defs/position" },
    snakeDirection: { $ref: "#/$defs/direction" },
    floatingFood: {
      type: "array",
      items: { $ref: "#/$defs/position" },
      default: [],
    },
    fallingFood: {
      type: "array",
      items: { $ref: "#/$defs/position" },
      default: [],
    },
    stones: { type: "array", items: { $ref: "#/$defs/position" }, default: [] },
    spikes: { type: "array", items: { $ref: "#/$defs/position" }, default: [] },
    exitIsSolid: { type: "boolean", default: true },
    totalFood: {
      type: "integer",
      minimum: 0,
      maximum: 4294967295,
      description:
        "Total food required for level completion. Expected to reflect food + floatingFood + fallingFood for editor/server round-trip consistency.",
    },
  },
  $defs: {
    position: {
      type: "object",
      additionalProperties: false,
      required: ["x", "y"],
      properties: {
        x: { type: "integer", minimum: 0, maximum: 2147483647 },
        y: { type: "integer", minimum: 0, maximum: 2147483647 },
      },
    },
    direction: { type: "string", enum: ["North", "South", "East", "West"] },
  },
};
const schema32 = {
  type: "object",
  additionalProperties: false,
  required: ["x", "y"],
  properties: {
    x: { type: "integer", minimum: 0, maximum: 2147483647 },
    y: { type: "integer", minimum: 0, maximum: 2147483647 },
  },
};
const schema36 = { type: "string", enum: ["North", "South", "East", "West"] };
const func1 = Object.prototype.hasOwnProperty;
import func2 from "ajv/dist/runtime/ucs2length.js";

function validate20(
  data,
  {
    instancePath = "",
    parentData,
    parentDataProperty,
    rootData = data,
    dynamicAnchors = {},
  } = {},
) {
  /*# sourceURL="https://gsnake.dev/schemas/level-definition.schema.json" */ let vErrors =
    null;
  let errors = 0;
  const evaluated0 = validate20.evaluated;
  if (evaluated0.dynamicProps) {
    evaluated0.props = undefined;
  }
  if (evaluated0.dynamicItems) {
    evaluated0.items = undefined;
  }
  if (data && typeof data == "object" && !Array.isArray(data)) {
    if (data.id === undefined) {
      const err0 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "id" },
        message: "must have required property '" + "id" + "'",
      };
      if (vErrors === null) {
        vErrors = [err0];
      } else {
        vErrors.push(err0);
      }
      errors++;
    }
    if (data.name === undefined) {
      const err1 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "name" },
        message: "must have required property '" + "name" + "'",
      };
      if (vErrors === null) {
        vErrors = [err1];
      } else {
        vErrors.push(err1);
      }
      errors++;
    }
    if (data.gridSize === undefined) {
      const err2 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "gridSize" },
        message: "must have required property '" + "gridSize" + "'",
      };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors++;
    }
    if (data.snake === undefined) {
      const err3 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "snake" },
        message: "must have required property '" + "snake" + "'",
      };
      if (vErrors === null) {
        vErrors = [err3];
      } else {
        vErrors.push(err3);
      }
      errors++;
    }
    if (data.obstacles === undefined) {
      const err4 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "obstacles" },
        message: "must have required property '" + "obstacles" + "'",
      };
      if (vErrors === null) {
        vErrors = [err4];
      } else {
        vErrors.push(err4);
      }
      errors++;
    }
    if (data.food === undefined) {
      const err5 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "food" },
        message: "must have required property '" + "food" + "'",
      };
      if (vErrors === null) {
        vErrors = [err5];
      } else {
        vErrors.push(err5);
      }
      errors++;
    }
    if (data.exit === undefined) {
      const err6 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "exit" },
        message: "must have required property '" + "exit" + "'",
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
    if (data.snakeDirection === undefined) {
      const err7 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "snakeDirection" },
        message: "must have required property '" + "snakeDirection" + "'",
      };
      if (vErrors === null) {
        vErrors = [err7];
      } else {
        vErrors.push(err7);
      }
      errors++;
    }
    if (data.totalFood === undefined) {
      const err8 = {
        instancePath,
        schemaPath: "#/required",
        keyword: "required",
        params: { missingProperty: "totalFood" },
        message: "must have required property '" + "totalFood" + "'",
      };
      if (vErrors === null) {
        vErrors = [err8];
      } else {
        vErrors.push(err8);
      }
      errors++;
    }
    for (const key0 in data) {
      if (!func1.call(schema31.properties, key0)) {
        const err9 = {
          instancePath,
          schemaPath: "#/additionalProperties",
          keyword: "additionalProperties",
          params: { additionalProperty: key0 },
          message: "must NOT have additional properties",
        };
        if (vErrors === null) {
          vErrors = [err9];
        } else {
          vErrors.push(err9);
        }
        errors++;
      }
    }
    if (data.id !== undefined) {
      let data0 = data.id;
      if (
        !(
          typeof data0 == "number" &&
          !(data0 % 1) &&
          !isNaN(data0) &&
          isFinite(data0)
        )
      ) {
        const err10 = {
          instancePath: instancePath + "/id",
          schemaPath: "#/properties/id/type",
          keyword: "type",
          params: { type: "integer" },
          message: "must be integer",
        };
        if (vErrors === null) {
          vErrors = [err10];
        } else {
          vErrors.push(err10);
        }
        errors++;
      }
      if (typeof data0 == "number" && isFinite(data0)) {
        if (data0 > 4294967295 || isNaN(data0)) {
          const err11 = {
            instancePath: instancePath + "/id",
            schemaPath: "#/properties/id/maximum",
            keyword: "maximum",
            params: { comparison: "<=", limit: 4294967295 },
            message: "must be <= 4294967295",
          };
          if (vErrors === null) {
            vErrors = [err11];
          } else {
            vErrors.push(err11);
          }
          errors++;
        }
        if (data0 < 0 || isNaN(data0)) {
          const err12 = {
            instancePath: instancePath + "/id",
            schemaPath: "#/properties/id/minimum",
            keyword: "minimum",
            params: { comparison: ">=", limit: 0 },
            message: "must be >= 0",
          };
          if (vErrors === null) {
            vErrors = [err12];
          } else {
            vErrors.push(err12);
          }
          errors++;
        }
      }
    }
    if (data.name !== undefined) {
      let data1 = data.name;
      if (typeof data1 === "string") {
        if (func2(data1) < 1) {
          const err13 = {
            instancePath: instancePath + "/name",
            schemaPath: "#/properties/name/minLength",
            keyword: "minLength",
            params: { limit: 1 },
            message: "must NOT have fewer than 1 characters",
          };
          if (vErrors === null) {
            vErrors = [err13];
          } else {
            vErrors.push(err13);
          }
          errors++;
        }
      } else {
        const err14 = {
          instancePath: instancePath + "/name",
          schemaPath: "#/properties/name/type",
          keyword: "type",
          params: { type: "string" },
          message: "must be string",
        };
        if (vErrors === null) {
          vErrors = [err14];
        } else {
          vErrors.push(err14);
        }
        errors++;
      }
    }
    if (data.difficulty !== undefined) {
      if (typeof data.difficulty !== "string") {
        const err15 = {
          instancePath: instancePath + "/difficulty",
          schemaPath: "#/properties/difficulty/type",
          keyword: "type",
          params: { type: "string" },
          message: "must be string",
        };
        if (vErrors === null) {
          vErrors = [err15];
        } else {
          vErrors.push(err15);
        }
        errors++;
      }
    }
    if (data.gridSize !== undefined) {
      let data3 = data.gridSize;
      if (data3 && typeof data3 == "object" && !Array.isArray(data3)) {
        if (data3.width === undefined) {
          const err16 = {
            instancePath: instancePath + "/gridSize",
            schemaPath: "#/properties/gridSize/required",
            keyword: "required",
            params: { missingProperty: "width" },
            message: "must have required property '" + "width" + "'",
          };
          if (vErrors === null) {
            vErrors = [err16];
          } else {
            vErrors.push(err16);
          }
          errors++;
        }
        if (data3.height === undefined) {
          const err17 = {
            instancePath: instancePath + "/gridSize",
            schemaPath: "#/properties/gridSize/required",
            keyword: "required",
            params: { missingProperty: "height" },
            message: "must have required property '" + "height" + "'",
          };
          if (vErrors === null) {
            vErrors = [err17];
          } else {
            vErrors.push(err17);
          }
          errors++;
        }
        for (const key1 in data3) {
          if (!(key1 === "width" || key1 === "height")) {
            const err18 = {
              instancePath: instancePath + "/gridSize",
              schemaPath: "#/properties/gridSize/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key1 },
              message: "must NOT have additional properties",
            };
            if (vErrors === null) {
              vErrors = [err18];
            } else {
              vErrors.push(err18);
            }
            errors++;
          }
        }
        if (data3.width !== undefined) {
          let data4 = data3.width;
          if (
            !(
              typeof data4 == "number" &&
              !(data4 % 1) &&
              !isNaN(data4) &&
              isFinite(data4)
            )
          ) {
            const err19 = {
              instancePath: instancePath + "/gridSize/width",
              schemaPath: "#/properties/gridSize/properties/width/type",
              keyword: "type",
              params: { type: "integer" },
              message: "must be integer",
            };
            if (vErrors === null) {
              vErrors = [err19];
            } else {
              vErrors.push(err19);
            }
            errors++;
          }
          if (typeof data4 == "number" && isFinite(data4)) {
            if (data4 > 2147483647 || isNaN(data4)) {
              const err20 = {
                instancePath: instancePath + "/gridSize/width",
                schemaPath: "#/properties/gridSize/properties/width/maximum",
                keyword: "maximum",
                params: { comparison: "<=", limit: 2147483647 },
                message: "must be <= 2147483647",
              };
              if (vErrors === null) {
                vErrors = [err20];
              } else {
                vErrors.push(err20);
              }
              errors++;
            }
            if (data4 < 1 || isNaN(data4)) {
              const err21 = {
                instancePath: instancePath + "/gridSize/width",
                schemaPath: "#/properties/gridSize/properties/width/minimum",
                keyword: "minimum",
                params: { comparison: ">=", limit: 1 },
                message: "must be >= 1",
              };
              if (vErrors === null) {
                vErrors = [err21];
              } else {
                vErrors.push(err21);
              }
              errors++;
            }
          }
        }
        if (data3.height !== undefined) {
          let data5 = data3.height;
          if (
            !(
              typeof data5 == "number" &&
              !(data5 % 1) &&
              !isNaN(data5) &&
              isFinite(data5)
            )
          ) {
            const err22 = {
              instancePath: instancePath + "/gridSize/height",
              schemaPath: "#/properties/gridSize/properties/height/type",
              keyword: "type",
              params: { type: "integer" },
              message: "must be integer",
            };
            if (vErrors === null) {
              vErrors = [err22];
            } else {
              vErrors.push(err22);
            }
            errors++;
          }
          if (typeof data5 == "number" && isFinite(data5)) {
            if (data5 > 2147483647 || isNaN(data5)) {
              const err23 = {
                instancePath: instancePath + "/gridSize/height",
                schemaPath: "#/properties/gridSize/properties/height/maximum",
                keyword: "maximum",
                params: { comparison: "<=", limit: 2147483647 },
                message: "must be <= 2147483647",
              };
              if (vErrors === null) {
                vErrors = [err23];
              } else {
                vErrors.push(err23);
              }
              errors++;
            }
            if (data5 < 1 || isNaN(data5)) {
              const err24 = {
                instancePath: instancePath + "/gridSize/height",
                schemaPath: "#/properties/gridSize/properties/height/minimum",
                keyword: "minimum",
                params: { comparison: ">=", limit: 1 },
                message: "must be >= 1",
              };
              if (vErrors === null) {
                vErrors = [err24];
              } else {
                vErrors.push(err24);
              }
              errors++;
            }
          }
        }
      } else {
        const err25 = {
          instancePath: instancePath + "/gridSize",
          schemaPath: "#/properties/gridSize/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object",
        };
        if (vErrors === null) {
          vErrors = [err25];
        } else {
          vErrors.push(err25);
        }
        errors++;
      }
    }
    if (data.snake !== undefined) {
      let data6 = data.snake;
      if (Array.isArray(data6)) {
        if (data6.length < 1) {
          const err26 = {
            instancePath: instancePath + "/snake",
            schemaPath: "#/properties/snake/minItems",
            keyword: "minItems",
            params: { limit: 1 },
            message: "must NOT have fewer than 1 items",
          };
          if (vErrors === null) {
            vErrors = [err26];
          } else {
            vErrors.push(err26);
          }
          errors++;
        }
        const len0 = data6.length;
        for (let i0 = 0; i0 < len0; i0++) {
          let data7 = data6[i0];
          if (data7 && typeof data7 == "object" && !Array.isArray(data7)) {
            if (data7.x === undefined) {
              const err27 = {
                instancePath: instancePath + "/snake/" + i0,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "x" },
                message: "must have required property '" + "x" + "'",
              };
              if (vErrors === null) {
                vErrors = [err27];
              } else {
                vErrors.push(err27);
              }
              errors++;
            }
            if (data7.y === undefined) {
              const err28 = {
                instancePath: instancePath + "/snake/" + i0,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "y" },
                message: "must have required property '" + "y" + "'",
              };
              if (vErrors === null) {
                vErrors = [err28];
              } else {
                vErrors.push(err28);
              }
              errors++;
            }
            for (const key2 in data7) {
              if (!(key2 === "x" || key2 === "y")) {
                const err29 = {
                  instancePath: instancePath + "/snake/" + i0,
                  schemaPath: "#/$defs/position/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: key2 },
                  message: "must NOT have additional properties",
                };
                if (vErrors === null) {
                  vErrors = [err29];
                } else {
                  vErrors.push(err29);
                }
                errors++;
              }
            }
            if (data7.x !== undefined) {
              let data8 = data7.x;
              if (
                !(
                  typeof data8 == "number" &&
                  !(data8 % 1) &&
                  !isNaN(data8) &&
                  isFinite(data8)
                )
              ) {
                const err30 = {
                  instancePath: instancePath + "/snake/" + i0 + "/x",
                  schemaPath: "#/$defs/position/properties/x/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err30];
                } else {
                  vErrors.push(err30);
                }
                errors++;
              }
              if (typeof data8 == "number" && isFinite(data8)) {
                if (data8 > 2147483647 || isNaN(data8)) {
                  const err31 = {
                    instancePath: instancePath + "/snake/" + i0 + "/x",
                    schemaPath: "#/$defs/position/properties/x/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err31];
                  } else {
                    vErrors.push(err31);
                  }
                  errors++;
                }
                if (data8 < 0 || isNaN(data8)) {
                  const err32 = {
                    instancePath: instancePath + "/snake/" + i0 + "/x",
                    schemaPath: "#/$defs/position/properties/x/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err32];
                  } else {
                    vErrors.push(err32);
                  }
                  errors++;
                }
              }
            }
            if (data7.y !== undefined) {
              let data9 = data7.y;
              if (
                !(
                  typeof data9 == "number" &&
                  !(data9 % 1) &&
                  !isNaN(data9) &&
                  isFinite(data9)
                )
              ) {
                const err33 = {
                  instancePath: instancePath + "/snake/" + i0 + "/y",
                  schemaPath: "#/$defs/position/properties/y/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err33];
                } else {
                  vErrors.push(err33);
                }
                errors++;
              }
              if (typeof data9 == "number" && isFinite(data9)) {
                if (data9 > 2147483647 || isNaN(data9)) {
                  const err34 = {
                    instancePath: instancePath + "/snake/" + i0 + "/y",
                    schemaPath: "#/$defs/position/properties/y/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err34];
                  } else {
                    vErrors.push(err34);
                  }
                  errors++;
                }
                if (data9 < 0 || isNaN(data9)) {
                  const err35 = {
                    instancePath: instancePath + "/snake/" + i0 + "/y",
                    schemaPath: "#/$defs/position/properties/y/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err35];
                  } else {
                    vErrors.push(err35);
                  }
                  errors++;
                }
              }
            }
          } else {
            const err36 = {
              instancePath: instancePath + "/snake/" + i0,
              schemaPath: "#/$defs/position/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            };
            if (vErrors === null) {
              vErrors = [err36];
            } else {
              vErrors.push(err36);
            }
            errors++;
          }
        }
      } else {
        const err37 = {
          instancePath: instancePath + "/snake",
          schemaPath: "#/properties/snake/type",
          keyword: "type",
          params: { type: "array" },
          message: "must be array",
        };
        if (vErrors === null) {
          vErrors = [err37];
        } else {
          vErrors.push(err37);
        }
        errors++;
      }
    }
    if (data.obstacles !== undefined) {
      let data10 = data.obstacles;
      if (Array.isArray(data10)) {
        const len1 = data10.length;
        for (let i1 = 0; i1 < len1; i1++) {
          let data11 = data10[i1];
          if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
            if (data11.x === undefined) {
              const err38 = {
                instancePath: instancePath + "/obstacles/" + i1,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "x" },
                message: "must have required property '" + "x" + "'",
              };
              if (vErrors === null) {
                vErrors = [err38];
              } else {
                vErrors.push(err38);
              }
              errors++;
            }
            if (data11.y === undefined) {
              const err39 = {
                instancePath: instancePath + "/obstacles/" + i1,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "y" },
                message: "must have required property '" + "y" + "'",
              };
              if (vErrors === null) {
                vErrors = [err39];
              } else {
                vErrors.push(err39);
              }
              errors++;
            }
            for (const key3 in data11) {
              if (!(key3 === "x" || key3 === "y")) {
                const err40 = {
                  instancePath: instancePath + "/obstacles/" + i1,
                  schemaPath: "#/$defs/position/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: key3 },
                  message: "must NOT have additional properties",
                };
                if (vErrors === null) {
                  vErrors = [err40];
                } else {
                  vErrors.push(err40);
                }
                errors++;
              }
            }
            if (data11.x !== undefined) {
              let data12 = data11.x;
              if (
                !(
                  typeof data12 == "number" &&
                  !(data12 % 1) &&
                  !isNaN(data12) &&
                  isFinite(data12)
                )
              ) {
                const err41 = {
                  instancePath: instancePath + "/obstacles/" + i1 + "/x",
                  schemaPath: "#/$defs/position/properties/x/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err41];
                } else {
                  vErrors.push(err41);
                }
                errors++;
              }
              if (typeof data12 == "number" && isFinite(data12)) {
                if (data12 > 2147483647 || isNaN(data12)) {
                  const err42 = {
                    instancePath: instancePath + "/obstacles/" + i1 + "/x",
                    schemaPath: "#/$defs/position/properties/x/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err42];
                  } else {
                    vErrors.push(err42);
                  }
                  errors++;
                }
                if (data12 < 0 || isNaN(data12)) {
                  const err43 = {
                    instancePath: instancePath + "/obstacles/" + i1 + "/x",
                    schemaPath: "#/$defs/position/properties/x/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err43];
                  } else {
                    vErrors.push(err43);
                  }
                  errors++;
                }
              }
            }
            if (data11.y !== undefined) {
              let data13 = data11.y;
              if (
                !(
                  typeof data13 == "number" &&
                  !(data13 % 1) &&
                  !isNaN(data13) &&
                  isFinite(data13)
                )
              ) {
                const err44 = {
                  instancePath: instancePath + "/obstacles/" + i1 + "/y",
                  schemaPath: "#/$defs/position/properties/y/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err44];
                } else {
                  vErrors.push(err44);
                }
                errors++;
              }
              if (typeof data13 == "number" && isFinite(data13)) {
                if (data13 > 2147483647 || isNaN(data13)) {
                  const err45 = {
                    instancePath: instancePath + "/obstacles/" + i1 + "/y",
                    schemaPath: "#/$defs/position/properties/y/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err45];
                  } else {
                    vErrors.push(err45);
                  }
                  errors++;
                }
                if (data13 < 0 || isNaN(data13)) {
                  const err46 = {
                    instancePath: instancePath + "/obstacles/" + i1 + "/y",
                    schemaPath: "#/$defs/position/properties/y/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err46];
                  } else {
                    vErrors.push(err46);
                  }
                  errors++;
                }
              }
            }
          } else {
            const err47 = {
              instancePath: instancePath + "/obstacles/" + i1,
              schemaPath: "#/$defs/position/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            };
            if (vErrors === null) {
              vErrors = [err47];
            } else {
              vErrors.push(err47);
            }
            errors++;
          }
        }
      } else {
        const err48 = {
          instancePath: instancePath + "/obstacles",
          schemaPath: "#/properties/obstacles/type",
          keyword: "type",
          params: { type: "array" },
          message: "must be array",
        };
        if (vErrors === null) {
          vErrors = [err48];
        } else {
          vErrors.push(err48);
        }
        errors++;
      }
    }
    if (data.food !== undefined) {
      let data14 = data.food;
      if (Array.isArray(data14)) {
        const len2 = data14.length;
        for (let i2 = 0; i2 < len2; i2++) {
          let data15 = data14[i2];
          if (data15 && typeof data15 == "object" && !Array.isArray(data15)) {
            if (data15.x === undefined) {
              const err49 = {
                instancePath: instancePath + "/food/" + i2,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "x" },
                message: "must have required property '" + "x" + "'",
              };
              if (vErrors === null) {
                vErrors = [err49];
              } else {
                vErrors.push(err49);
              }
              errors++;
            }
            if (data15.y === undefined) {
              const err50 = {
                instancePath: instancePath + "/food/" + i2,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "y" },
                message: "must have required property '" + "y" + "'",
              };
              if (vErrors === null) {
                vErrors = [err50];
              } else {
                vErrors.push(err50);
              }
              errors++;
            }
            for (const key4 in data15) {
              if (!(key4 === "x" || key4 === "y")) {
                const err51 = {
                  instancePath: instancePath + "/food/" + i2,
                  schemaPath: "#/$defs/position/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: key4 },
                  message: "must NOT have additional properties",
                };
                if (vErrors === null) {
                  vErrors = [err51];
                } else {
                  vErrors.push(err51);
                }
                errors++;
              }
            }
            if (data15.x !== undefined) {
              let data16 = data15.x;
              if (
                !(
                  typeof data16 == "number" &&
                  !(data16 % 1) &&
                  !isNaN(data16) &&
                  isFinite(data16)
                )
              ) {
                const err52 = {
                  instancePath: instancePath + "/food/" + i2 + "/x",
                  schemaPath: "#/$defs/position/properties/x/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err52];
                } else {
                  vErrors.push(err52);
                }
                errors++;
              }
              if (typeof data16 == "number" && isFinite(data16)) {
                if (data16 > 2147483647 || isNaN(data16)) {
                  const err53 = {
                    instancePath: instancePath + "/food/" + i2 + "/x",
                    schemaPath: "#/$defs/position/properties/x/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err53];
                  } else {
                    vErrors.push(err53);
                  }
                  errors++;
                }
                if (data16 < 0 || isNaN(data16)) {
                  const err54 = {
                    instancePath: instancePath + "/food/" + i2 + "/x",
                    schemaPath: "#/$defs/position/properties/x/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err54];
                  } else {
                    vErrors.push(err54);
                  }
                  errors++;
                }
              }
            }
            if (data15.y !== undefined) {
              let data17 = data15.y;
              if (
                !(
                  typeof data17 == "number" &&
                  !(data17 % 1) &&
                  !isNaN(data17) &&
                  isFinite(data17)
                )
              ) {
                const err55 = {
                  instancePath: instancePath + "/food/" + i2 + "/y",
                  schemaPath: "#/$defs/position/properties/y/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err55];
                } else {
                  vErrors.push(err55);
                }
                errors++;
              }
              if (typeof data17 == "number" && isFinite(data17)) {
                if (data17 > 2147483647 || isNaN(data17)) {
                  const err56 = {
                    instancePath: instancePath + "/food/" + i2 + "/y",
                    schemaPath: "#/$defs/position/properties/y/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err56];
                  } else {
                    vErrors.push(err56);
                  }
                  errors++;
                }
                if (data17 < 0 || isNaN(data17)) {
                  const err57 = {
                    instancePath: instancePath + "/food/" + i2 + "/y",
                    schemaPath: "#/$defs/position/properties/y/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err57];
                  } else {
                    vErrors.push(err57);
                  }
                  errors++;
                }
              }
            }
          } else {
            const err58 = {
              instancePath: instancePath + "/food/" + i2,
              schemaPath: "#/$defs/position/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            };
            if (vErrors === null) {
              vErrors = [err58];
            } else {
              vErrors.push(err58);
            }
            errors++;
          }
        }
      } else {
        const err59 = {
          instancePath: instancePath + "/food",
          schemaPath: "#/properties/food/type",
          keyword: "type",
          params: { type: "array" },
          message: "must be array",
        };
        if (vErrors === null) {
          vErrors = [err59];
        } else {
          vErrors.push(err59);
        }
        errors++;
      }
    }
    if (data.exit !== undefined) {
      let data18 = data.exit;
      if (data18 && typeof data18 == "object" && !Array.isArray(data18)) {
        if (data18.x === undefined) {
          const err60 = {
            instancePath: instancePath + "/exit",
            schemaPath: "#/$defs/position/required",
            keyword: "required",
            params: { missingProperty: "x" },
            message: "must have required property '" + "x" + "'",
          };
          if (vErrors === null) {
            vErrors = [err60];
          } else {
            vErrors.push(err60);
          }
          errors++;
        }
        if (data18.y === undefined) {
          const err61 = {
            instancePath: instancePath + "/exit",
            schemaPath: "#/$defs/position/required",
            keyword: "required",
            params: { missingProperty: "y" },
            message: "must have required property '" + "y" + "'",
          };
          if (vErrors === null) {
            vErrors = [err61];
          } else {
            vErrors.push(err61);
          }
          errors++;
        }
        for (const key5 in data18) {
          if (!(key5 === "x" || key5 === "y")) {
            const err62 = {
              instancePath: instancePath + "/exit",
              schemaPath: "#/$defs/position/additionalProperties",
              keyword: "additionalProperties",
              params: { additionalProperty: key5 },
              message: "must NOT have additional properties",
            };
            if (vErrors === null) {
              vErrors = [err62];
            } else {
              vErrors.push(err62);
            }
            errors++;
          }
        }
        if (data18.x !== undefined) {
          let data19 = data18.x;
          if (
            !(
              typeof data19 == "number" &&
              !(data19 % 1) &&
              !isNaN(data19) &&
              isFinite(data19)
            )
          ) {
            const err63 = {
              instancePath: instancePath + "/exit/x",
              schemaPath: "#/$defs/position/properties/x/type",
              keyword: "type",
              params: { type: "integer" },
              message: "must be integer",
            };
            if (vErrors === null) {
              vErrors = [err63];
            } else {
              vErrors.push(err63);
            }
            errors++;
          }
          if (typeof data19 == "number" && isFinite(data19)) {
            if (data19 > 2147483647 || isNaN(data19)) {
              const err64 = {
                instancePath: instancePath + "/exit/x",
                schemaPath: "#/$defs/position/properties/x/maximum",
                keyword: "maximum",
                params: { comparison: "<=", limit: 2147483647 },
                message: "must be <= 2147483647",
              };
              if (vErrors === null) {
                vErrors = [err64];
              } else {
                vErrors.push(err64);
              }
              errors++;
            }
            if (data19 < 0 || isNaN(data19)) {
              const err65 = {
                instancePath: instancePath + "/exit/x",
                schemaPath: "#/$defs/position/properties/x/minimum",
                keyword: "minimum",
                params: { comparison: ">=", limit: 0 },
                message: "must be >= 0",
              };
              if (vErrors === null) {
                vErrors = [err65];
              } else {
                vErrors.push(err65);
              }
              errors++;
            }
          }
        }
        if (data18.y !== undefined) {
          let data20 = data18.y;
          if (
            !(
              typeof data20 == "number" &&
              !(data20 % 1) &&
              !isNaN(data20) &&
              isFinite(data20)
            )
          ) {
            const err66 = {
              instancePath: instancePath + "/exit/y",
              schemaPath: "#/$defs/position/properties/y/type",
              keyword: "type",
              params: { type: "integer" },
              message: "must be integer",
            };
            if (vErrors === null) {
              vErrors = [err66];
            } else {
              vErrors.push(err66);
            }
            errors++;
          }
          if (typeof data20 == "number" && isFinite(data20)) {
            if (data20 > 2147483647 || isNaN(data20)) {
              const err67 = {
                instancePath: instancePath + "/exit/y",
                schemaPath: "#/$defs/position/properties/y/maximum",
                keyword: "maximum",
                params: { comparison: "<=", limit: 2147483647 },
                message: "must be <= 2147483647",
              };
              if (vErrors === null) {
                vErrors = [err67];
              } else {
                vErrors.push(err67);
              }
              errors++;
            }
            if (data20 < 0 || isNaN(data20)) {
              const err68 = {
                instancePath: instancePath + "/exit/y",
                schemaPath: "#/$defs/position/properties/y/minimum",
                keyword: "minimum",
                params: { comparison: ">=", limit: 0 },
                message: "must be >= 0",
              };
              if (vErrors === null) {
                vErrors = [err68];
              } else {
                vErrors.push(err68);
              }
              errors++;
            }
          }
        }
      } else {
        const err69 = {
          instancePath: instancePath + "/exit",
          schemaPath: "#/$defs/position/type",
          keyword: "type",
          params: { type: "object" },
          message: "must be object",
        };
        if (vErrors === null) {
          vErrors = [err69];
        } else {
          vErrors.push(err69);
        }
        errors++;
      }
    }
    if (data.snakeDirection !== undefined) {
      let data21 = data.snakeDirection;
      if (typeof data21 !== "string") {
        const err70 = {
          instancePath: instancePath + "/snakeDirection",
          schemaPath: "#/$defs/direction/type",
          keyword: "type",
          params: { type: "string" },
          message: "must be string",
        };
        if (vErrors === null) {
          vErrors = [err70];
        } else {
          vErrors.push(err70);
        }
        errors++;
      }
      if (
        !(
          data21 === "North" ||
          data21 === "South" ||
          data21 === "East" ||
          data21 === "West"
        )
      ) {
        const err71 = {
          instancePath: instancePath + "/snakeDirection",
          schemaPath: "#/$defs/direction/enum",
          keyword: "enum",
          params: { allowedValues: schema36.enum },
          message: "must be equal to one of the allowed values",
        };
        if (vErrors === null) {
          vErrors = [err71];
        } else {
          vErrors.push(err71);
        }
        errors++;
      }
    }
    if (data.floatingFood !== undefined) {
      let data22 = data.floatingFood;
      if (Array.isArray(data22)) {
        const len3 = data22.length;
        for (let i3 = 0; i3 < len3; i3++) {
          let data23 = data22[i3];
          if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
            if (data23.x === undefined) {
              const err72 = {
                instancePath: instancePath + "/floatingFood/" + i3,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "x" },
                message: "must have required property '" + "x" + "'",
              };
              if (vErrors === null) {
                vErrors = [err72];
              } else {
                vErrors.push(err72);
              }
              errors++;
            }
            if (data23.y === undefined) {
              const err73 = {
                instancePath: instancePath + "/floatingFood/" + i3,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "y" },
                message: "must have required property '" + "y" + "'",
              };
              if (vErrors === null) {
                vErrors = [err73];
              } else {
                vErrors.push(err73);
              }
              errors++;
            }
            for (const key6 in data23) {
              if (!(key6 === "x" || key6 === "y")) {
                const err74 = {
                  instancePath: instancePath + "/floatingFood/" + i3,
                  schemaPath: "#/$defs/position/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: key6 },
                  message: "must NOT have additional properties",
                };
                if (vErrors === null) {
                  vErrors = [err74];
                } else {
                  vErrors.push(err74);
                }
                errors++;
              }
            }
            if (data23.x !== undefined) {
              let data24 = data23.x;
              if (
                !(
                  typeof data24 == "number" &&
                  !(data24 % 1) &&
                  !isNaN(data24) &&
                  isFinite(data24)
                )
              ) {
                const err75 = {
                  instancePath: instancePath + "/floatingFood/" + i3 + "/x",
                  schemaPath: "#/$defs/position/properties/x/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err75];
                } else {
                  vErrors.push(err75);
                }
                errors++;
              }
              if (typeof data24 == "number" && isFinite(data24)) {
                if (data24 > 2147483647 || isNaN(data24)) {
                  const err76 = {
                    instancePath: instancePath + "/floatingFood/" + i3 + "/x",
                    schemaPath: "#/$defs/position/properties/x/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err76];
                  } else {
                    vErrors.push(err76);
                  }
                  errors++;
                }
                if (data24 < 0 || isNaN(data24)) {
                  const err77 = {
                    instancePath: instancePath + "/floatingFood/" + i3 + "/x",
                    schemaPath: "#/$defs/position/properties/x/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err77];
                  } else {
                    vErrors.push(err77);
                  }
                  errors++;
                }
              }
            }
            if (data23.y !== undefined) {
              let data25 = data23.y;
              if (
                !(
                  typeof data25 == "number" &&
                  !(data25 % 1) &&
                  !isNaN(data25) &&
                  isFinite(data25)
                )
              ) {
                const err78 = {
                  instancePath: instancePath + "/floatingFood/" + i3 + "/y",
                  schemaPath: "#/$defs/position/properties/y/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err78];
                } else {
                  vErrors.push(err78);
                }
                errors++;
              }
              if (typeof data25 == "number" && isFinite(data25)) {
                if (data25 > 2147483647 || isNaN(data25)) {
                  const err79 = {
                    instancePath: instancePath + "/floatingFood/" + i3 + "/y",
                    schemaPath: "#/$defs/position/properties/y/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err79];
                  } else {
                    vErrors.push(err79);
                  }
                  errors++;
                }
                if (data25 < 0 || isNaN(data25)) {
                  const err80 = {
                    instancePath: instancePath + "/floatingFood/" + i3 + "/y",
                    schemaPath: "#/$defs/position/properties/y/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err80];
                  } else {
                    vErrors.push(err80);
                  }
                  errors++;
                }
              }
            }
          } else {
            const err81 = {
              instancePath: instancePath + "/floatingFood/" + i3,
              schemaPath: "#/$defs/position/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            };
            if (vErrors === null) {
              vErrors = [err81];
            } else {
              vErrors.push(err81);
            }
            errors++;
          }
        }
      } else {
        const err82 = {
          instancePath: instancePath + "/floatingFood",
          schemaPath: "#/properties/floatingFood/type",
          keyword: "type",
          params: { type: "array" },
          message: "must be array",
        };
        if (vErrors === null) {
          vErrors = [err82];
        } else {
          vErrors.push(err82);
        }
        errors++;
      }
    }
    if (data.fallingFood !== undefined) {
      let data26 = data.fallingFood;
      if (Array.isArray(data26)) {
        const len4 = data26.length;
        for (let i4 = 0; i4 < len4; i4++) {
          let data27 = data26[i4];
          if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
            if (data27.x === undefined) {
              const err83 = {
                instancePath: instancePath + "/fallingFood/" + i4,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "x" },
                message: "must have required property '" + "x" + "'",
              };
              if (vErrors === null) {
                vErrors = [err83];
              } else {
                vErrors.push(err83);
              }
              errors++;
            }
            if (data27.y === undefined) {
              const err84 = {
                instancePath: instancePath + "/fallingFood/" + i4,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "y" },
                message: "must have required property '" + "y" + "'",
              };
              if (vErrors === null) {
                vErrors = [err84];
              } else {
                vErrors.push(err84);
              }
              errors++;
            }
            for (const key7 in data27) {
              if (!(key7 === "x" || key7 === "y")) {
                const err85 = {
                  instancePath: instancePath + "/fallingFood/" + i4,
                  schemaPath: "#/$defs/position/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: key7 },
                  message: "must NOT have additional properties",
                };
                if (vErrors === null) {
                  vErrors = [err85];
                } else {
                  vErrors.push(err85);
                }
                errors++;
              }
            }
            if (data27.x !== undefined) {
              let data28 = data27.x;
              if (
                !(
                  typeof data28 == "number" &&
                  !(data28 % 1) &&
                  !isNaN(data28) &&
                  isFinite(data28)
                )
              ) {
                const err86 = {
                  instancePath: instancePath + "/fallingFood/" + i4 + "/x",
                  schemaPath: "#/$defs/position/properties/x/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err86];
                } else {
                  vErrors.push(err86);
                }
                errors++;
              }
              if (typeof data28 == "number" && isFinite(data28)) {
                if (data28 > 2147483647 || isNaN(data28)) {
                  const err87 = {
                    instancePath: instancePath + "/fallingFood/" + i4 + "/x",
                    schemaPath: "#/$defs/position/properties/x/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err87];
                  } else {
                    vErrors.push(err87);
                  }
                  errors++;
                }
                if (data28 < 0 || isNaN(data28)) {
                  const err88 = {
                    instancePath: instancePath + "/fallingFood/" + i4 + "/x",
                    schemaPath: "#/$defs/position/properties/x/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err88];
                  } else {
                    vErrors.push(err88);
                  }
                  errors++;
                }
              }
            }
            if (data27.y !== undefined) {
              let data29 = data27.y;
              if (
                !(
                  typeof data29 == "number" &&
                  !(data29 % 1) &&
                  !isNaN(data29) &&
                  isFinite(data29)
                )
              ) {
                const err89 = {
                  instancePath: instancePath + "/fallingFood/" + i4 + "/y",
                  schemaPath: "#/$defs/position/properties/y/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err89];
                } else {
                  vErrors.push(err89);
                }
                errors++;
              }
              if (typeof data29 == "number" && isFinite(data29)) {
                if (data29 > 2147483647 || isNaN(data29)) {
                  const err90 = {
                    instancePath: instancePath + "/fallingFood/" + i4 + "/y",
                    schemaPath: "#/$defs/position/properties/y/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err90];
                  } else {
                    vErrors.push(err90);
                  }
                  errors++;
                }
                if (data29 < 0 || isNaN(data29)) {
                  const err91 = {
                    instancePath: instancePath + "/fallingFood/" + i4 + "/y",
                    schemaPath: "#/$defs/position/properties/y/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err91];
                  } else {
                    vErrors.push(err91);
                  }
                  errors++;
                }
              }
            }
          } else {
            const err92 = {
              instancePath: instancePath + "/fallingFood/" + i4,
              schemaPath: "#/$defs/position/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            };
            if (vErrors === null) {
              vErrors = [err92];
            } else {
              vErrors.push(err92);
            }
            errors++;
          }
        }
      } else {
        const err93 = {
          instancePath: instancePath + "/fallingFood",
          schemaPath: "#/properties/fallingFood/type",
          keyword: "type",
          params: { type: "array" },
          message: "must be array",
        };
        if (vErrors === null) {
          vErrors = [err93];
        } else {
          vErrors.push(err93);
        }
        errors++;
      }
    }
    if (data.stones !== undefined) {
      let data30 = data.stones;
      if (Array.isArray(data30)) {
        const len5 = data30.length;
        for (let i5 = 0; i5 < len5; i5++) {
          let data31 = data30[i5];
          if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
            if (data31.x === undefined) {
              const err94 = {
                instancePath: instancePath + "/stones/" + i5,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "x" },
                message: "must have required property '" + "x" + "'",
              };
              if (vErrors === null) {
                vErrors = [err94];
              } else {
                vErrors.push(err94);
              }
              errors++;
            }
            if (data31.y === undefined) {
              const err95 = {
                instancePath: instancePath + "/stones/" + i5,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "y" },
                message: "must have required property '" + "y" + "'",
              };
              if (vErrors === null) {
                vErrors = [err95];
              } else {
                vErrors.push(err95);
              }
              errors++;
            }
            for (const key8 in data31) {
              if (!(key8 === "x" || key8 === "y")) {
                const err96 = {
                  instancePath: instancePath + "/stones/" + i5,
                  schemaPath: "#/$defs/position/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: key8 },
                  message: "must NOT have additional properties",
                };
                if (vErrors === null) {
                  vErrors = [err96];
                } else {
                  vErrors.push(err96);
                }
                errors++;
              }
            }
            if (data31.x !== undefined) {
              let data32 = data31.x;
              if (
                !(
                  typeof data32 == "number" &&
                  !(data32 % 1) &&
                  !isNaN(data32) &&
                  isFinite(data32)
                )
              ) {
                const err97 = {
                  instancePath: instancePath + "/stones/" + i5 + "/x",
                  schemaPath: "#/$defs/position/properties/x/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err97];
                } else {
                  vErrors.push(err97);
                }
                errors++;
              }
              if (typeof data32 == "number" && isFinite(data32)) {
                if (data32 > 2147483647 || isNaN(data32)) {
                  const err98 = {
                    instancePath: instancePath + "/stones/" + i5 + "/x",
                    schemaPath: "#/$defs/position/properties/x/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err98];
                  } else {
                    vErrors.push(err98);
                  }
                  errors++;
                }
                if (data32 < 0 || isNaN(data32)) {
                  const err99 = {
                    instancePath: instancePath + "/stones/" + i5 + "/x",
                    schemaPath: "#/$defs/position/properties/x/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err99];
                  } else {
                    vErrors.push(err99);
                  }
                  errors++;
                }
              }
            }
            if (data31.y !== undefined) {
              let data33 = data31.y;
              if (
                !(
                  typeof data33 == "number" &&
                  !(data33 % 1) &&
                  !isNaN(data33) &&
                  isFinite(data33)
                )
              ) {
                const err100 = {
                  instancePath: instancePath + "/stones/" + i5 + "/y",
                  schemaPath: "#/$defs/position/properties/y/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err100];
                } else {
                  vErrors.push(err100);
                }
                errors++;
              }
              if (typeof data33 == "number" && isFinite(data33)) {
                if (data33 > 2147483647 || isNaN(data33)) {
                  const err101 = {
                    instancePath: instancePath + "/stones/" + i5 + "/y",
                    schemaPath: "#/$defs/position/properties/y/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err101];
                  } else {
                    vErrors.push(err101);
                  }
                  errors++;
                }
                if (data33 < 0 || isNaN(data33)) {
                  const err102 = {
                    instancePath: instancePath + "/stones/" + i5 + "/y",
                    schemaPath: "#/$defs/position/properties/y/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err102];
                  } else {
                    vErrors.push(err102);
                  }
                  errors++;
                }
              }
            }
          } else {
            const err103 = {
              instancePath: instancePath + "/stones/" + i5,
              schemaPath: "#/$defs/position/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            };
            if (vErrors === null) {
              vErrors = [err103];
            } else {
              vErrors.push(err103);
            }
            errors++;
          }
        }
      } else {
        const err104 = {
          instancePath: instancePath + "/stones",
          schemaPath: "#/properties/stones/type",
          keyword: "type",
          params: { type: "array" },
          message: "must be array",
        };
        if (vErrors === null) {
          vErrors = [err104];
        } else {
          vErrors.push(err104);
        }
        errors++;
      }
    }
    if (data.spikes !== undefined) {
      let data34 = data.spikes;
      if (Array.isArray(data34)) {
        const len6 = data34.length;
        for (let i6 = 0; i6 < len6; i6++) {
          let data35 = data34[i6];
          if (data35 && typeof data35 == "object" && !Array.isArray(data35)) {
            if (data35.x === undefined) {
              const err105 = {
                instancePath: instancePath + "/spikes/" + i6,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "x" },
                message: "must have required property '" + "x" + "'",
              };
              if (vErrors === null) {
                vErrors = [err105];
              } else {
                vErrors.push(err105);
              }
              errors++;
            }
            if (data35.y === undefined) {
              const err106 = {
                instancePath: instancePath + "/spikes/" + i6,
                schemaPath: "#/$defs/position/required",
                keyword: "required",
                params: { missingProperty: "y" },
                message: "must have required property '" + "y" + "'",
              };
              if (vErrors === null) {
                vErrors = [err106];
              } else {
                vErrors.push(err106);
              }
              errors++;
            }
            for (const key9 in data35) {
              if (!(key9 === "x" || key9 === "y")) {
                const err107 = {
                  instancePath: instancePath + "/spikes/" + i6,
                  schemaPath: "#/$defs/position/additionalProperties",
                  keyword: "additionalProperties",
                  params: { additionalProperty: key9 },
                  message: "must NOT have additional properties",
                };
                if (vErrors === null) {
                  vErrors = [err107];
                } else {
                  vErrors.push(err107);
                }
                errors++;
              }
            }
            if (data35.x !== undefined) {
              let data36 = data35.x;
              if (
                !(
                  typeof data36 == "number" &&
                  !(data36 % 1) &&
                  !isNaN(data36) &&
                  isFinite(data36)
                )
              ) {
                const err108 = {
                  instancePath: instancePath + "/spikes/" + i6 + "/x",
                  schemaPath: "#/$defs/position/properties/x/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err108];
                } else {
                  vErrors.push(err108);
                }
                errors++;
              }
              if (typeof data36 == "number" && isFinite(data36)) {
                if (data36 > 2147483647 || isNaN(data36)) {
                  const err109 = {
                    instancePath: instancePath + "/spikes/" + i6 + "/x",
                    schemaPath: "#/$defs/position/properties/x/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err109];
                  } else {
                    vErrors.push(err109);
                  }
                  errors++;
                }
                if (data36 < 0 || isNaN(data36)) {
                  const err110 = {
                    instancePath: instancePath + "/spikes/" + i6 + "/x",
                    schemaPath: "#/$defs/position/properties/x/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err110];
                  } else {
                    vErrors.push(err110);
                  }
                  errors++;
                }
              }
            }
            if (data35.y !== undefined) {
              let data37 = data35.y;
              if (
                !(
                  typeof data37 == "number" &&
                  !(data37 % 1) &&
                  !isNaN(data37) &&
                  isFinite(data37)
                )
              ) {
                const err111 = {
                  instancePath: instancePath + "/spikes/" + i6 + "/y",
                  schemaPath: "#/$defs/position/properties/y/type",
                  keyword: "type",
                  params: { type: "integer" },
                  message: "must be integer",
                };
                if (vErrors === null) {
                  vErrors = [err111];
                } else {
                  vErrors.push(err111);
                }
                errors++;
              }
              if (typeof data37 == "number" && isFinite(data37)) {
                if (data37 > 2147483647 || isNaN(data37)) {
                  const err112 = {
                    instancePath: instancePath + "/spikes/" + i6 + "/y",
                    schemaPath: "#/$defs/position/properties/y/maximum",
                    keyword: "maximum",
                    params: { comparison: "<=", limit: 2147483647 },
                    message: "must be <= 2147483647",
                  };
                  if (vErrors === null) {
                    vErrors = [err112];
                  } else {
                    vErrors.push(err112);
                  }
                  errors++;
                }
                if (data37 < 0 || isNaN(data37)) {
                  const err113 = {
                    instancePath: instancePath + "/spikes/" + i6 + "/y",
                    schemaPath: "#/$defs/position/properties/y/minimum",
                    keyword: "minimum",
                    params: { comparison: ">=", limit: 0 },
                    message: "must be >= 0",
                  };
                  if (vErrors === null) {
                    vErrors = [err113];
                  } else {
                    vErrors.push(err113);
                  }
                  errors++;
                }
              }
            }
          } else {
            const err114 = {
              instancePath: instancePath + "/spikes/" + i6,
              schemaPath: "#/$defs/position/type",
              keyword: "type",
              params: { type: "object" },
              message: "must be object",
            };
            if (vErrors === null) {
              vErrors = [err114];
            } else {
              vErrors.push(err114);
            }
            errors++;
          }
        }
      } else {
        const err115 = {
          instancePath: instancePath + "/spikes",
          schemaPath: "#/properties/spikes/type",
          keyword: "type",
          params: { type: "array" },
          message: "must be array",
        };
        if (vErrors === null) {
          vErrors = [err115];
        } else {
          vErrors.push(err115);
        }
        errors++;
      }
    }
    if (data.exitIsSolid !== undefined) {
      if (typeof data.exitIsSolid !== "boolean") {
        const err116 = {
          instancePath: instancePath + "/exitIsSolid",
          schemaPath: "#/properties/exitIsSolid/type",
          keyword: "type",
          params: { type: "boolean" },
          message: "must be boolean",
        };
        if (vErrors === null) {
          vErrors = [err116];
        } else {
          vErrors.push(err116);
        }
        errors++;
      }
    }
    if (data.totalFood !== undefined) {
      let data39 = data.totalFood;
      if (
        !(
          typeof data39 == "number" &&
          !(data39 % 1) &&
          !isNaN(data39) &&
          isFinite(data39)
        )
      ) {
        const err117 = {
          instancePath: instancePath + "/totalFood",
          schemaPath: "#/properties/totalFood/type",
          keyword: "type",
          params: { type: "integer" },
          message: "must be integer",
        };
        if (vErrors === null) {
          vErrors = [err117];
        } else {
          vErrors.push(err117);
        }
        errors++;
      }
      if (typeof data39 == "number" && isFinite(data39)) {
        if (data39 > 4294967295 || isNaN(data39)) {
          const err118 = {
            instancePath: instancePath + "/totalFood",
            schemaPath: "#/properties/totalFood/maximum",
            keyword: "maximum",
            params: { comparison: "<=", limit: 4294967295 },
            message: "must be <= 4294967295",
          };
          if (vErrors === null) {
            vErrors = [err118];
          } else {
            vErrors.push(err118);
          }
          errors++;
        }
        if (data39 < 0 || isNaN(data39)) {
          const err119 = {
            instancePath: instancePath + "/totalFood",
            schemaPath: "#/properties/totalFood/minimum",
            keyword: "minimum",
            params: { comparison: ">=", limit: 0 },
            message: "must be >= 0",
          };
          if (vErrors === null) {
            vErrors = [err119];
          } else {
            vErrors.push(err119);
          }
          errors++;
        }
      }
    }
  } else {
    const err120 = {
      instancePath,
      schemaPath: "#/type",
      keyword: "type",
      params: { type: "object" },
      message: "must be object",
    };
    if (vErrors === null) {
      vErrors = [err120];
    } else {
      vErrors.push(err120);
    }
    errors++;
  }
  validate20.errors = vErrors;
  return errors === 0;
}
validate20.evaluated = {
  props: true,
  dynamicProps: false,
  dynamicItems: false,
};

export function isLevelDefinition(data: unknown): boolean {
  return Boolean(validateLevelDefinition(data));
}

function normalizeFieldPath(instancePath, params) {
  if (params && typeof params === "object") {
    if (typeof params.missingProperty === "string") {
      return `${instancePath || "$"}.${params.missingProperty}`;
    }
    if (typeof params.additionalProperty === "string") {
      return `${instancePath || "$"}.${params.additionalProperty}`;
    }
  }
  return instancePath || "$";
}

export function getLevelDefinitionValidationIssues() {
  return (validateLevelDefinition.errors ?? []).map((error) => ({
    field: normalizeFieldPath(error.instancePath, error.params),
    keyword: error.keyword,
    message: error.message ?? "validation error",
  }));
}
